using System.Collections.Generic;
using System.Linq;
using Scoop.SyntaxTree.Visiting;
using Scoop.Validation;

namespace Scoop.SyntaxTree
{
    public abstract class AstNode
    {
        public abstract AstNode Accept(IAstNodeVisitorImplementation visitor);

        // Error messages attached to this node
        public IReadOnlyList<Diagnostic> Diagnostics { get; private set; }

        // The location where this production happens in the source (may be the beginning of the production
        // or the location of the defining feature of it)
        public Location Location { get; set; }

        // Unused nodes which were generated by the parser (and which may contain diagnostics or metadata)
        // but which aren't needed in the final tree.
        public IReadOnlyList<AstNode> Unused { get; private set; }

        public void AddUnusedMembers(params AstNode[] unused)
        {
            // TODO: combine if the list isn't empty
            Unused = unused;
        }

        public void AddDiagnostics(params Diagnostic[] diagnostics)
        {
            // TODO: combine if the list isn't empty
            Diagnostics = diagnostics;
        }
    }

    public static class AstNodeExtensions
    {
        /// <summary>
        /// Add unused nodes which are generated by the parser but which are not required for the final tree
        /// </summary>
        /// <typeparam name="TNode"></typeparam>
        /// <param name="node"></param>
        /// <param name="unused"></param>
        /// <returns></returns>
        public static TNode WithUnused<TNode>(this TNode node, params AstNode[] unused)
            where TNode : AstNode
        {
            node.AddUnusedMembers(unused);
            return node;
        }

        /// <summary>
        /// Add diagnostic/error messages to this node
        /// </summary>
        /// <typeparam name="TNode"></typeparam>
        /// <param name="node"></param>
        /// <param name="diagnostics"></param>
        /// <returns></returns>
        public static TNode WithDiagnostics<TNode>(this TNode node, params Diagnostic[] diagnostics)
            where TNode : AstNode
        {
            node.AddDiagnostics(diagnostics);
            return node;
        }

        /// <summary>
        /// Add diagnostic/error messages to this node
        /// </summary>
        /// <typeparam name="TNode"></typeparam>
        /// <param name="node"></param>
        /// <param name="l"></param>
        /// <param name="diagnostics"></param>
        /// <returns></returns>
        public static TNode WithDiagnostics<TNode>(this TNode node, Location l, params string[] diagnostics)
            where TNode : AstNode
        {
            node.AddDiagnostics(diagnostics.Select(d => new Diagnostic(d, l)).ToArray());
            return node;
        }

        /// <summary>
        /// Validate this node, extracting all diagnostics messages from this node and children
        /// </summary>
        /// <param name="node"></param>
        /// <returns></returns>
        public static IReadOnlyList<Diagnostic> Validate(this AstNode node)
        {
            var errors = new List<Diagnostic>();
            new ValidationVisitor(errors).Visit(node);
            return errors;
        }
    }
}
